// File: uart_tx.v
// Generated by MyHDL 0.11
// Date: Sun Feb  2 19:53:59 2020


`timescale 1ns/10ps

module uart_tx (
    clk,
    reset,
    serial_out,
    byte_in,
    start,
    done
);
// A simple UART tx module with a fixed baud rate, one start bit, one stop bit, and no parity bit.
// clk -- The input clock
// reset -- The reset signal
// serial_out -- The serial data signal, it is high when inactive
// byte_in -- The 8 bit number to send
// start -- Input, drive high for one clock cycle to signal that byte_in is valid and should begin sending
// done -- Output, is driven high for one clock cycle to signal that the transmitter is done sending
// baud -- A Baud object, which represents the incoming baud rate of the interface

input clk;
input reset;
output serial_out;
wire serial_out;
input [7:0] byte_in;
input start;
output done;
wire done;

reg [0:0] full_bit_done;
wire [0:0] full_bit_tstart;
reg [9:0] shift_reg;
reg [0:0] state;
reg [3:0] bit_count;
reg [6:0] timer0_timer;
reg [0:0] timer0_state;



always @(timer0_timer) begin: UART_TX_TIMER0_COMB_LOGIC
    if ((timer0_timer == 0)) begin
        full_bit_done = 1;
    end
    else begin
        full_bit_done = 0;
    end
end


always @(posedge clk, negedge reset) begin: UART_TX_TIMER0_SEQ_LOGIC
    if (reset == 0) begin
        timer0_timer <= 99;
        timer0_state <= 1'b0;
    end
    else begin
        case (timer0_state)
            1'b0: begin
                timer0_state <= 1'b0;
                if ((full_bit_tstart == 1)) begin
                    timer0_state <= 1'b1;
                end
            end
            1'b1: begin
                timer0_state <= 1'b1;
                if ((timer0_timer == 0)) begin
                    timer0_timer <= (100 - 1);
                    if ((full_bit_tstart == 0)) begin
                        timer0_state <= 1'b0;
                    end
                    else begin
                        timer0_state <= 1'b1;
                    end
                end
                else begin
                    timer0_timer <= (timer0_timer - 1);
                end
            end
            default: begin
                $finish;
            end
        endcase
    end
end


always @(posedge clk, negedge reset) begin: UART_TX_INCREMENTER0_SEQ_LOGC
    if (reset == 0) begin
        bit_count <= 0;
    end
    else begin
        if ((done == 1)) begin
            bit_count <= 0;
        end
        else if (($signed({1'b0, bit_count}) == (10 - 1))) begin
            bit_count <= bit_count;
        end
        else if ((full_bit_done == 1)) begin
            bit_count <= (bit_count + 1);
        end
        else begin
            bit_count <= bit_count;
        end
    end
end



assign done = ((state == 1'b1) && ($signed({1'b0, bit_count}) == (10 - 1)) && (full_bit_done == 1));



assign full_bit_tstart = (((state == 1'b0) && start) || ((state == 1'b1) && (((full_bit_done == 1) && (!(done == 1))) || ((start == 1) && (done == 1)))));
assign serial_out = shift_reg[0];


always @(posedge clk, negedge reset) begin: UART_TX_FSM_SEQ_LOGIC
    if (reset == 0) begin
        state <= 1'b0;
        shift_reg <= 1023;
    end
    else begin
        state <= state;
        shift_reg <= shift_reg;
        case (state)
            1'b0: begin
                if (start) begin
                    state <= 1'b1;
                    shift_reg <= {1'b1, byte_in[8-1:0], 1'b0};
                end
            end
            1'b1: begin
                if (full_bit_done) begin
                    shift_reg <= {1'b1, shift_reg[10-1:1]};
                end
                if (done) begin
                    if (start) begin
                        shift_reg <= {1'b1, byte_in[8-1:0], 1'b0};
                    end
                    else begin
                        state <= 1'b0;
                    end
                end
            end
            default: begin
                $finish;
            end
        endcase
    end
end

endmodule
